================================================================================
DOMAIN-SPECIFIC FINE-TUNING & TECHNICAL IMPLEMENTATION DETAILS
================================================================================

PROJECT: Phiversity - Domain-Restricted Language Model
OBJECTIVE: Fine-tune LM to respond ONLY to Physics, Math, Economics, and Chemistry
DATE: February 2026

================================================================================
1. FINE-TUNING REQUIREMENTS FOR DOMAIN RESTRICTION
================================================================================

1.1 RESOURCE SPECIFICATION
----------------------------
ALLOWED RESOURCES:
  â€¢ Physics Textbooks and Journals (Classical, Quantum, Thermodynamics)
  â€¢ Mathematics References (Algebra, Calculus, Linear Algebra, Statistics)
  â€¢ Economics Papers (Microeconomics, Macroeconomics, Econometrics)
  â€¢ Chemistry Databases (Organic, Inorganic, Physical Chemistry)
  
PROHIBITED RESOURCES:
  â€¢ General Knowledge Bases (Wikipedia, News Articles)
  â€¢ Social Media Content
  â€¢ Entertainment Materials
  â€¢ Unverified Online Forums
  â€¢ Non-Academic Sources

1.2 MODEL BEHAVIOR CONSTRAINTS
-----------------------------
The fine-tuned model MUST:
  âœ“ Accept ONLY questions about Physics, Math, Economics, Chemistry
  âœ“ Refuse politely for out-of-domain questions
  âœ“ Cite academic sources when providing answers
  âœ“ Maintain mathematical accuracy and rigor
  âœ“ Provide step-by-step explanations
  âœ“ Validate numerical answers
  
The model MUST NOT:
  âœ— Provide general advice outside the four domains
  âœ— Answer subjective or opinion-based questions
  âœ— Access real-time information outside training scope
  âœ— Generate content unrelated to STEM subjects

1.3 FINE-TUNING APPROACH
------------------------
INSTRUCTION TUNING:
  â€¢ Create domain-specific prompt templates
  â€¢ Use few-shot learning examples
  â€¢ Implement instruction following with domain awareness
  
REINFORCEMENT LEARNING FROM HUMAN FEEDBACK (RLHF):
  â€¢ Train reward model on domain accuracy
  â€¢ Penalize off-domain responses
  â€¢ Reinforce multi-step reasoning
  â€¢ Optimize for pedagogical quality

1.4 TRAINING DATA PREPARATION
------------------------------
  â€¢ Dataset Size: 100K+ domain-specific Q&A pairs
  â€¢ Source Quality: Verified academic materials only
  â€¢ Balance: Equal representation across 4 domains
  â€¢ Validation: Expert review of all training examples
  â€¢ Test Coverage: Edge cases and boundary conditions

================================================================================
2. OVERLAPPING PROBLEM RESOLUTION (GRAPH FIGURES & TEXT)
================================================================================

2.1 PROBLEM DESCRIPTION
-----------------------
ISSUE: Graph figures overlap with explanatory text in the learning interface
IMPACT: 
  â€¢ Reduced readability of educational content
  â€¢ Poor user experience during problem solving
  â€¢ Text becomes obscured by visualization
  â€¢ Mathematical equations overlap with graphs

2.2 ROOT CAUSE ANALYSIS
----------------------
  Root Cause 1: Absolute Positioning Without Bounds Checking
    - Layout system places elements without checking available space
    - No dynamic reflow when content overlaps
    - Fixed coordinates don't adapt to content size

  Root Cause 2: Insufficient Padding/Margin Configuration
    - Text boxes placed too close to graph boundaries
    - No buffer zones for different screen sizes
    - Responsive design not implemented

  Root Cause 3: Z-Index Stacking Context Issues
    - Graphs drawn after text without proper layering
    - No proper order of rendering elements
    - CSS stacking context not properly managed

2.3 SOLUTION IMPLEMENTATION
---------------------------
APPROACH A: FLEXBOX-BASED LAYOUT
  â€¢ Convert fixed positioning to flexbox/grid
  â€¢ Implement two-column layout: [Graph | Text]
  â€¢ Use CSS Grid for responsive design
  â€¢ Add dynamic spacing based on content size

APPROACH B: INTELLIGENT REFLOW ALGORITHM
  â€¢ Detect collision between graph and text regions
  â€¢ Automatically reposition overlapping elements
  â€¢ Maintain aspect ratios and readability
  â€¢ Scale elements proportionally if space is limited

APPROACH C: LAYERED VISUALIZATION
  â€¢ Separate logical layers: background, graphs, text, annotations
  â€¢ Implement z-index management system
  â€¢ Use transparent overlays with proper opacity
  â€¢ Ensure text always renders on top of graphs

2.4 TECHNICAL IMPLEMENTATION
----------------------------
CSS Solution:
  ```
  .graph-text-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 2rem;
    min-height: 500px;
    align-items: start;
  }
  
  .graph-wrapper {
    position: relative;
    overflow: hidden;
    border: 1px solid #ccc;
    padding: 1rem;
    max-height: 600px;
  }
  
  .text-explanation {
    padding: 1.5rem;
    line-height: 1.6;
    overflow-y: auto;
    position: relative;
    z-index: 10;
  }
  ```

Python/Matplotlib Solution:
  ```
  import matplotlib.pyplot as plt
  from matplotlib.gridspec import GridSpec
  
  fig = plt.figure(figsize=(14, 8))
  gs = GridSpec(1, 2, figure=fig, width_ratios=[1, 1], wspace=0.3)
  
  ax_graph = fig.add_subplot(gs[0, 0])
  ax_text = fig.add_subplot(gs[0, 1])
  
  # Plot graph in left axis
  ax_graph.plot(x, y)
  ax_graph.set_title('Mathematical Model')
  
  # Add text in right axis
  ax_text.axis('off')
  ax_text.text(0.1, 0.9, explanation_text, transform=ax_text.transAxes,
               fontsize=11, verticalalignment='top', wrap=True)
  ```

2.5 COLLISION DETECTION & CORRECTION
------------------------------------
ALGORITHM:
  1. Get bounding boxes for all elements (graph, text, equations)
  2. Check for overlaps using AABB (Axis-Aligned Bounding Box)
  3. If collision detected:
     a. Calculate intersection area
     b. Move text element by minimum distance needed
     c. Or resize graph to fit constraints
     d. Or adjust layout to side-by-side arrangement
  4. Verify readability of adjusted layout
  5. Cache layout solution for similar content

================================================================================
3. STEP EXECUTION ISSUES RESOLUTION (JUMP, MISS, CROSS)
================================================================================

3.1 PROBLEM DESCRIPTION
-----------------------
ISSUE SET A: STEP JUMPING
  â€¢ Solution steps skip intermediate calculations
  â€¢ Jump from step N directly to step N+2 or N+3
  â€¢ Critical operations missing between visible steps
  â€¢ User cannot follow logical flow

ISSUE SET B: MISSED STEPS
  â€¢ Important steps not displayed
  â€¢ Hidden steps in solution path
  â€¢ Incomplete problem decomposition
  â€¢ Missing prerequisite calculations

ISSUE SET C: CROSSED STEPS / STEP CROSSING
  â€¢ Step order becomes confused
  â€¢ Dependencies between steps not respected
  â€¢ Earlier steps use results from later steps
  â€¢ Circular dependencies in step ordering

3.2 ROOT CAUSE ANALYSIS
-----------------------
CAUSE 1: Insufficient Step Decomposition
  - Algorithm doesn't break problems into atomic steps
  - No granularity control in step generation
  - Complex operations not subdivided
  
CAUSE 2: Missing Dependency Tracking
  - No graph of step dependencies created
  - Steps executed without checking prerequisites
  - Topological sort not implemented
  
CAUSE 3: Output Formatting Issues
  - Steps filtered or skipped during rendering
  - Caching returns incomplete results
  - Step numbering logic flawed

CAUSE 4: Circular Dependencies
  - Step A requires output from Step B
  - Step B requires output from Step A
  - No cycle detection in dependency graph

3.3 SOLUTION IMPLEMENTATION
---------------------------
STEP 1: IMPLEMENT FINE-GRAINED STEP DECOMPOSITION
  
  Problem Decomposition Pattern:
  
  Original (High-level):
    Step 1: Solve quadratic equation 2xÂ² + 3x + 1 = 0
    Step 2: Apply quadratic formula
    Step 3: Calculate discriminant
    *** JUMP TO FINAL ANSWER ***
  
  Refined (Fine-grained):
    Step 1: Identify coefficients: a=2, b=3, c=1
    Step 2: Write quadratic formula: x = (-b Â± âˆš(bÂ²-4ac)) / 2a
    Step 3: Calculate bÂ²: 3Â² = 9
    Step 4: Calculate 4ac: 4 Ã— 2 Ã— 1 = 8
    Step 5: Calculate discriminant: Î” = bÂ² - 4ac = 9 - 8 = 1
    Step 6: Calculate âˆšÎ”: âˆš1 = 1
    Step 7: Calculate numerator 1: -b + âˆšÎ” = -3 + 1 = -2
    Step 8: Calculate numerator 2: -b - âˆšÎ” = -3 - 1 = -4
    Step 9: Calculate denominator: 2a = 2 Ã— 2 = 4
    Step 10: Calculate xâ‚: -2/4 = -1/2
    Step 11: Calculate xâ‚‚: -4/4 = -1
    Step 12: Verify solution 1: 2(-1/2)Â² + 3(-1/2) + 1 = 1/2 - 3/2 + 1 = 0 âœ“
    Step 13: Verify solution 2: 2(-1)Â² + 3(-1) + 1 = 2 - 3 + 1 = 0 âœ“
    Step 14: Final Answer: x = -1/2, x = -1

STEP 2: IMPLEMENT DEPENDENCY TRACKING
  
  Dependency Graph Structure:
  ```
  Step Graph: {
    step_1: { dependencies: [], outputs: ['a', 'b', 'c'] },
    step_2: { dependencies: [], outputs: ['formula'] },
    step_3: { dependencies: ['b'], outputs: ['b_squared'] },
    step_4: { dependencies: ['a', 'c'], outputs: ['4ac'] },
    step_5: { dependencies: ['b_squared', '4ac'], outputs: ['discriminant'] },
    step_6: { dependencies: ['discriminant'], outputs: ['sqrt_discriminant'] },
    ...
    step_12: { dependencies: ['a', 'b', 'c', 'solution_1'], outputs: ['verification_1'] },
  }
  ```

STEP 3: IMPLEMENT TOPOLOGICAL SORT
  
  Algorithm:
  ```
  function topological_sort(steps, dependencies):
    visited = set()
    visit_stack = []
    
    def visit(step, visiting):
      if step in visited:
        return
      if step in visiting:
        raise CyclicalDependencyError(step)  # Detect cycles
      
      visiting.add(step)
      for dep in dependencies[step]:
        visit(dep, visiting)
      visiting.remove(step)
      visited.add(step)
      visit_stack.append(step)
    
    for step in steps:
      visit(step, set())
    
    return reversed(visit_stack)  # Return in correct order
  ```

STEP 4: IMPLEMENT VALIDATION & VERIFICATION
  
  Validation Checks:
  âœ“ No missing steps in sequence
  âœ“ No circular dependencies
  âœ“ All prerequisites available before step execution
  âœ“ Output variables match expected types
  âœ“ Numerical accuracy within tolerance
  âœ“ Physical unit consistency (if applicable)

3.4 STEP DISPLAY & RENDERING LOGIC
----------------------------------
```python
class StepExecutor:
    def __init__(self, problem_data):
        self.steps = self.decompose_problem(problem_data)
        self.dependency_graph = self.build_dependency_graph()
        self.sorted_steps = self.topological_sort(self.steps)
        
    def decompose_problem(self, problem):
        """Break complex problem into atomic steps"""
        atomic_steps = []
        # Subdivide operations until minimal steps achieved
        for step in problem.steps:
            atomic_steps.extend(self.subdivide_step(step))
        return atomic_steps
    
    def build_dependency_graph(self):
        """Create and validate dependency relationships"""
        graph = {}
        for step in self.steps:
            step_inputs = step.get_required_variables()
            step_outputs = step.get_produced_variables()
            graph[step.id] = {
                'dependencies': self.find_providing_steps(step_inputs),
                'outputs': step_outputs,
                'is_root': len(self.find_providing_steps(step_inputs)) == 0
            }
        
        # Verify no circular dependencies
        if self.has_cycles(graph):
            raise CircularDependencyError("Step ordering is circular")
        
        return graph
    
    def topological_sort(self, steps):
        """Order steps respecting all dependencies"""
        sorted_order = []
        visited = set()
        
        def visit(step_id, visiting):
            if step_id in visited:
                return
            if step_id in visiting:
                raise CircularDependencyError(f"Circular at {step_id}")
            
            visiting.add(step_id)
            for dep_id in self.dependency_graph[step_id]['dependencies']:
                visit(dep_id, visiting)
            visiting.remove(step_id)
            visited.add(step_id)
            sorted_order.append(step_id)
        
        for step in steps:
            visit(step.id, set())
        
        return sorted_order
    
    def execute_and_render(self):
        """Execute steps in order and render each one"""
        execution_context = {}
        rendered_steps = []
        
        for step_id in self.sorted_steps:
            step = self.get_step_by_id(step_id)
            
            # Verify prerequisites available
            for prereq_var in step.required_variables:
                if prereq_var not in execution_context:
                    raise MissingPrerequisiteError(f"{prereq_var} not available")
            
            # Execute step
            result = step.execute(execution_context)
            execution_context.update(result)
            
            # Render step
            rendered = self.render_step(step, result)
            rendered_steps.append(rendered)
        
        return rendered_steps
```

3.5 PREVENTION OF STEP ISSUES
----------------------------
AUTOMATED VALIDATION:
  âœ“ Syntax checking: Verify each step is complete
  âœ“ Semantic checking: Verify variables exist before use
  âœ“ Type checking: Ensure numerical operations use numbers
  âœ“ Unit checking: Verify physics units are consistent
  âœ“ Accuracy checking: Verify numerical results
  âœ“ Logic checking: Verify mathematical correctness

TESTING REQUIREMENTS:
  â€¢ Test step decomposition with 50+ problems
  â€¢ Test dependency resolution for complex problems
  â€¢ Test cycle detection with intentional circular inputs
  â€¢ Test rendering of steps with 100+ intermediate calculations
  â€¢ Test numerical accuracy with floating-point edge cases

3.6 EDGE CASES & SPECIAL HANDLING
--------------------------------
EDGE CASE 1: Alternative Solution Paths
  Problem: Multiple valid solutions (e.g., completing the square vs. quadratic formula)
  Solution: Track all valid paths, let user choose method
  
EDGE CASE 2: Implicit Steps
  Problem: Some steps commonly skipped by experts (e.g., "obviously 2x2=4")
  Solution: Configurable step granularity level (basic, intermediate, detailed)
  
EDGE CASE 3: Missing Intermediate Variables
  Problem: Solution uses undefined intermediate results
  Solution: Backtrack and regenerate missing steps automatically
  
EDGE CASE 4: Numerical Precision Issues
  Problem: Rounding errors accumulate across steps
  Solution: Use symbolic computation where possible, detect precision loss

================================================================================
4. INTEGRATION WITH PHIVERSITY PLATFORM
================================================================================

4.1 USER INTERFACE IMPROVEMENTS
-------------------------------
  â€¢ Display steps sequentially with clear numbering
  â€¢ Show dependency tree visualization
  â€¢ Highlight which step output is used in next step
  â€¢ Allow toggling between detailed and simplified views
  â€¢ Provide "show more details" for each step

4.2 TESTING FRAMEWORK
--------------------
  â€¢ Automated verification of step sequences
  â€¢ Numerical accuracy testing (tolerance: 1e-10)
  â€¢ Coverage testing for all problem types
  â€¢ Regression testing before deployment

4.3 DEPLOYMENT CHECKLIST
-----------------------
  â˜ Fine-tuning complete and validated
  â˜ Domain restrictions verified
  â˜ Graph/text overlap issues resolved
  â˜ Step execution logic tested
  â˜ UI/UX improvements implemented
  â˜ Documentation updated
  â˜ User testing completed
  â˜ Production deployment scheduled

4.4 WIKIPEDIA HISTORY & BIOGRAPHICAL ENRICHMENT
-----------------------------------------------
OVERVIEW:
  Enhance LLM fine-tuning by automatically fetching historical context,
  biographical information, and short introductions of key figures and
  concepts mentioned in questions and answers.

4.4.1 INTEGRATION WITH QUESTION PROCESSING
------------------------------------------
When a question is submitted, the system will:
  1. Parse question to identify key entities (scientists, concepts, theorems)
  2. Fetch Wikipedia summaries for discovered entities
  3. Enrich the prompt context with brief biographical/historical info
  4. Use enriched context to improve answer quality and relevance

EXAMPLE WORKFLOW:

  User Question: "What is quantum entanglement and who discovered it?"
  
  Entity Detection:
    â€¢ Concept: "quantum entanglement"
    â€¢ Person: "Einstein" (implied)
  
  Wikipedia Enrichment:
    Quantum Entanglement (Wikipedia Summary):
      "Quantum entanglement is a physical phenomenon occurring when a pair or
       group of particles is generated, interact, or share spatial proximity in
       a way such that the quantum state of each particle of the pair or group
       cannot be described independently..."
    
    Albert Einstein (Biography Summary):
      "Albert Einstein (1879-1955) was a German-born theoretical physicist who
       developed the theory of relativity, one of the two pillars of modern
       physics. He won the Nobel Prize in Physics in 1921 for his services to
       theoretical physics, and for his discovery of the law of the
       photoelectric effect..."
  
  Person: Erwin SchrÃ¶dinger (Related Scientist)
    "Erwin Rudolf Josef Alexander SchrÃ¶dinger (1887-1961) was an Austrian
     physicist and theoretical biologist who was one of the fathers of quantum
     mechanics. He shared the 1933 Nobel Prize in Physics with Paul Dirac..."
  
  Enhanced Response:
    "Quantum entanglement is a phenomenon where particles become correlated
     in quantum states. While Albert Einstein called it 'spooky action at a
     distance,' the concept was developed through work by SchrÃ¶dinger and
     others. SchrÃ¶dinger actually proposed the famous SchrÃ¶dinger's cat
     thought experiment in 1935 to explain the paradoxes of quantum mechanics..."

4.4.2 IMPLEMENTATION ARCHITECTURE
--------------------------------
```python
import wikipedia
import re
from typing import List, Dict, Tuple

class WikipediaContextEnricher:
    def __init__(self, domains=['Physics', 'Mathematics', 'Chemistry', 'Economics']):
        self.domains = domains
        self.cache = {}  # Cache Wikipedia summaries
        self.entity_patterns = self._build_entity_patterns()
    
    def extract_entities(self, text: str) -> Tuple[List[str], List[str]]:
        """
        Extract key entities (people, concepts, theorems) from text
        Returns: (people, concepts)
        """
        people = []
        concepts = []
        
        # Named entity recognition for scientists/economists/mathematicians
        person_keywords = ['physicist', 'scientist', 'mathematician', 'chemist',
                          'economist', 'researcher', 'inventor', 'philosopher']
        
        sentences = text.split('.')
        for sentence in sentences:
            # Extract capitalized names (likely proper nouns)
            names = re.findall(r'\b[A-Z][a-z]+\s+[A-Z][a-z]+\b', sentence)
            people.extend(names)
            
            # Extract quoted/emphasized concepts
            concepts_found = re.findall(r'"([^"]+)"|\'([^\']+)\'', sentence)
            concepts.extend([c[0] or c[1] for c in concepts_found])
        
        return list(set(people)), list(set(concepts))
    
    def fetch_wikipedia_summary(self, entity: str, max_sentences: int = 3) -> Dict:
        """
        Fetch Wikipedia summary for an entity
        Returns: {'title', 'summary', 'url', 'categories', 'birth_year', 'death_year'}
        """
        if entity in self.cache:
            return self.cache[entity]
        
        try:
            # Search Wikipedia
            search_results = wikipedia.search(entity, results=5)
            if not search_results:
                return None
            
            # Get the most relevant result
            page = wikipedia.page(search_results[0], auto_suggest=False)
            
            # Extract summary (first N sentences)
            summary_text = page.summary
            sentences = summary_text.split('.')
            short_summary = '. '.join(sentences[:max_sentences]) + '.'
            
            # Extract biographical info if person
            infobox = self._extract_infobox_info(page)
            
            result = {
                'title': page.title,
                'summary': short_summary,
                'full_summary': summary_text,
                'url': page.url,
                'categories': page.categories[:5],  # Top 5 categories
                'birth_year': infobox.get('birth_year'),
                'death_year': infobox.get('death_year'),
                'fields': infobox.get('fields', []),  # e.g., Physics, Chemistry
                'notable_works': infobox.get('notable_works', [])
            }
            
            self.cache[entity] = result
            return result
            
        except (wikipedia.exceptions.DisambiguationError, 
                wikipedia.exceptions.PageError,
                Exception):
            return None
    
    def enrich_question_context(self, question: str) -> str:
        """
        Add Wikipedia context to enhance question understanding
        """
        people, concepts = self.extract_entities(question)
        enriched_context = "=== ENRICHED CONTEXT ===\n"
        
        # Add people information
        for person in people[:3]:  # Limit to top 3
            info = self.fetch_wikipedia_summary(person, max_sentences=2)
            if info:
                enriched_context += f"\n[PERSON] {info['title']}:\n"
                enriched_context += f"  {info['summary']}\n"
        
        # Add concepts information  
        for concept in concepts[:3]:  # Limit to top 3
            info = self.fetch_wikipedia_summary(concept, max_sentences=2)
            if info:
                enriched_context += f"\n[CONCEPT] {info['title']}:\n"
                enriched_context += f"  {info['summary']}\n"
        
        return enriched_context
    
    def create_biography_card(self, person: str) -> str:
        """
        Generate a formatted biography card for display
        """
        info = self.fetch_wikipedia_summary(person)
        if not info:
            return f"[Information not found for {person}]"
        
        card = f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ BIOGRAPHICAL INFORMATION                     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

NAME: {info['title']}
"""
        if info['birth_year']:
            card += f"BORN: {info['birth_year']}\n"
        if info['death_year']:
            card += f"DIED: {info['death_year']}\n"
        
        if info['fields']:
            card += f"FIELDS: {', '.join(info['fields'])}\n"
        
        card += f"\nSUMMARY:\n{info['summary']}\n"
        
        if info['notable_works']:
            card += f"\nNOTABLE WORKS:\n"
            for work in info['notable_works'][:5]:
                card += f"  â€¢ {work}\n"
        
        card += f"\nSOURCE: {info['url']}\n"
        
        return card
    
    def _extract_infobox_info(self, page) -> Dict:
        """Extract structured information from Wikipedia infobox"""
        info = {}
        # Parse infobox data (simplified - full implementation would parse HTML)
        try:
            # Extract birth/death years from summary if present
            birth_match = re.search(r'\((\d{4})â€“', page.summary)
            death_match = re.search(r'â€“(\d{4})\)', page.summary)
            
            if birth_match:
                info['birth_year'] = birth_match.group(1)
            if death_match:
                info['death_year'] = death_match.group(1)
        except:
            pass
        
        return info
    
    def _build_entity_patterns(self) -> Dict:
        """Build regex patterns for entity detection"""
        return {
            'scientists': r'\b(Newton|Einstein|Curie|Feynman|Hawking|Darwin)\b',
            'mathematicians': r'\b(Euler|Gauss|Riemann|Ramanujan)\b',
            'economists': r'\b(Smith|Keynes|Marx|Friedman)\b',
            'chemists': r'\b(Bohr|Heisenberg|Planck|Dirac)\b'
        }
```

4.4.3 FINE-TUNING WITH WIKIPEDIA CONTEXT
----------------------------------------
TRAINING DATA ENRICHMENT:

Step 1: Collect Domain Questions
  â€¢ 50,000+ physics, math, chemistry, economics questions
  â€¢ Include questions mentioning key figures and concepts
  
Step 2: Extract Entities
  â€¢ Run entity extraction on all questions
  â€¢ Identify 1,000+ key figures and concepts
  
Step 3: Fetch Wikipedia Information
  â€¢ Retrieve 2-3 sentence summaries for each entity
  â€¢ Cache results to avoid redundant API calls
  
Step 4: Create Enhanced Training Pairs
  Original Pair:
    Input: "What was Einstein's contribution to physics?"
    Target: "Albert Einstein developed the theory of relativity..."
  
  Enhanced Pair:
    Input: "What was Einstein's contribution to physics?
            [CONTEXT: Albert Einstein (1879-1955) was a theoretical physicist...]"
    Target: "Albert Einstein, the renowned theoretical physicist who developed
            the theory of relativity, made groundbreaking contributions..."

Step 5: Fine-tune LLM
  â€¢ Train with enriched input-output pairs
  â€¢ Model learns to leverage biographical/historical context
  â€¢ Improves answer depth and accuracy

4.4.4 USER INTERFACE FEATURES
----------------------------
FEATURE 1: Concept Cards
  â€¢ When entity mentioned, display Wikipedia summary card
  â€¢ Show thumbnail image if available
  â€¢ Link to full Wikipedia article
  
FEATURE 2: Person Timeline
  â€¢ Display life span of scientists/economists mentioned
  â€¢ Show contemporary figures and their contributions
  â€¢ Visual timeline of discovery periods
  
FEATURE 3: Related Concepts
  â€¢ Show other important concepts in same domain
  â€¢ Link to related Wikipedia articles
  â€¢ Build knowledge graph connections
  
FEATURE 4: Historical Context
  â€¢ When discussing discovery, show historical period
  â€¢ Display competing theories of the time
  â€¢ Show evolution of concept understanding

EXAMPLE UI DISPLAY:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Question: What is quantum entanglement? â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ðŸ“š CONTEXT ENRICHMENT
  [ðŸ‘¤] SchrÃ¶dinger, Erwin (1887-1961)
      Austrian physicist, father of quantum mechanics
      
  [ðŸ“–] Quantum Mechanics - Fundamental theory in physics
  
  [ðŸ‘¤] Einstein, Albert (1879-1955)
      Theoretical physicist, theory of relativity

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

[AI RESPONSE with enhanced context...]
```

4.4.5 CACHING & PERFORMANCE OPTIMIZATION
----------------------------------------
WIKIPEDIA API CACHING:
  â€¢ Use persistent cache (JSON file or database)
  â€¢ Cache expires after 30 days (Wikipedia updates)
  â€¢ Store: entity_name â†’ {title, summary, url, categories}
  â€¢ Reduces API calls by 95% for repeated questions
  
BATCH PROCESSING:
  â€¢ Pre-cache 1,000+ common scientists/concepts
  â€¢ Extract during off-peak hours
  â€¢ Store in SQLite database for fast retrieval
  
ASYNC FETCHING:
  â€¢ Non-blocking Wikipedia queries
  â€¢ Don't delay question answering for enrichment
  â€¢ Load context asynchronously in background
  
EXAMPLE CACHE STRUCTURE:
  ```json
  {
    "Albert Einstein": {
      "title": "Albert Einstein",
      "summary": "Albert Einstein (1879-1955) was a German-born theoretical physicist...",
      "url": "https://en.wikipedia.org/wiki/Albert_Einstein",
      "birth_year": "1879",
      "death_year": "1955",
      "fields": ["Physics", "Theoretical Physics", "Relativity"],
      "cached_at": "2026-02-11",
      "expires_at": "2026-03-13"
    },
    "Quantum Entanglement": {
      "title": "Quantum entanglement",
      "summary": "Quantum entanglement is a physical phenomenon occurring when...",
      "url": "https://en.wikipedia.org/wiki/Quantum_entanglement",
      "cached_at": "2026-02-11",
      "expires_at": "2026-03-13"
    }
  }
  ```

4.4.6 QUALITY CONTROL FOR WIKIPEDIA CONTENT
-------------------------------------------
CHALLENGES:
  Ã— Wikipedia accuracy varies by article
  Ã— Some articles biased or incomplete
  Ã— Not all pages have reliable information
  
SOLUTIONS:
  âœ“ Use only well-sourced Wikipedia articles (citations required)
  âœ“ Cross-reference with academic databases
  âœ“ Manual review of top 100 scientists/concepts
  âœ“ Fact-check against domain textbooks
  âœ“ Flag low-quality or incomplete Wikipedia entries
  âœ“ Set confidence scores for different entity types

VALIDATION CHECKLIST:
  â˜ Wikipedia summary factually accurate (verified by domain expert)
  â˜ Source has 5+ citations (reliability indicator)
  â˜ Article updated within last 2 years
  â˜ Information consistent with textbook knowledge
  â˜ Dates and facts mathematically verified
  â˜ No contradictions with training data

================================================================================
5. QUALITY ASSURANCE METRICS
================================================================================

SUCCESS CRITERIA:
  â€¢ Domain accuracy: >95% of responses are in-domain correct
  â€¢ Step completeness: 100% of solutions show all intermediate steps
  â€¢ Overlap resolution: 0 cases of text-graph overlap reported
  â€¢ Step ordering: 0 cases of incorrect step sequence
  â€¢ User satisfaction: >4.5/5 star rating
  â€¢ Load time: <2 seconds per problem solution

================================================================================
6. MANIM EDUCATIONAL ANIMATION SYSTEM INTEGRATION
================================================================================

OVERVIEW:
  The Phiversity platform integrates a sophisticated Manim animation pipeline
  to convert step-by-step solutions into high-quality educational videos.
  The system translates natural language queries into machine-executable JSON
  animation plans that generate visual explanations for Physics, Math, 
  Economics, and Chemistry problems.

6.1 MANIM PROMPT SYSTEM ARCHITECTURE
-----------------------------------
The system operates as an "Architect of Educational Animation" that takes
user queries and produces rigorous JSON-based animation plans.

CORE RESPONSIBILITIES:
  1. Parse user's natural language mathematical/scientific question
  2. Decompose problem into pedagogically sound steps
  3. Generate detailed explanations with LaTeX equations
  4. Create animation plan with scene-by-scene visual strategy
  5. Specify element positioning with collision detection
  6. Synchronize voiceover (TTS) with visual animations
  7. Validate all outputs against 250+ error prevention checklist

6.2 JSON SCHEMA FOR ANIMATION GENERATION
----------------------------------------
Every animation output MUST conform to this structure:

```json
{
  "solution": {
    "topic": "String describing subject (e.g., 'Calculus: Chain Rule')",
    "steps": [
      {
        "title": "Short header for step",
        "explanation": "Detailed educational walkthrough",
        "latex": "\\frac{dy}{dx} = ... (LaTeX equation)"
      }
    ],
    "final_answer": "Conclusive answer with verification"
  },
  "animation_plan": {
    "overview": "Internal notes on visual strategy",
    "scenes": [
      {
        "id": "unique_scene_identifier",
        "description": "Human-readable scene description",
        "voiceover": "Phonetically-written TTS script (see rules below)",
        "elements": [
          {
            "type": "Text|Latex|MathTex|Axes|Graph|Polygon|Circle|Arrow|VectorField",
            "content": "Mathematical expression or visual content",
            "position": "[x, y, z]",  // Cartesian coordinates
            "style": { "color": "#HEX", "font_size": 48 },
            "timing": {
              "start": 0.0,           // Absolute time in seconds
              "duration_in": 1.0,     // Animation entry duration
              "transition_in": "Write|Create|FadeIn|GrowFromCenter",
              "transition_out": "FadeOut|Uncreate"
            }
          }
        ]
      }
    ]
  }
}
```

6.3 COORDINATE SYSTEM SPECIFICATION
----------------------------------
CRITICAL: All position-based elements use a Cartesian coordinate system:

SCREEN BOUNDS:
  â€¢ X-axis: -7.1 (Left Edge) to +7.1 (Right Edge)
  â€¢ Y-axis: -4.0 (Bottom Edge) to +4.0 (Top Edge)  
  â€¢ Z-axis: 0 (default, 3D only when necessary)
  â€¢ Center: [0, 0, 0]
  
POSITIONING RULES:
  Title (top): [0, 3.5, 0]
  Graph (left): [-3.5, 0, 0]
  Text explanation (right): [3.5, 0, 0]
  Bottom content: [0, -3.0, 0]

SAFE MARGINS:
  Keep all elements within [-6.6, +6.6] (X) and [-3.5, +3.5] (Y)
  Minimum spacing: 0.5 units between adjacent elements

6.4 MATHEMATICAL SYNTAX REQUIREMENTS
-----------------------------------
PYTHON SYNTAX (for Graph/Calculation content):
  Ã— INVALID: 2x, x^2, sin(x)cos(x)
  âœ“ VALID: 2*x, x**2, sin(x)*cos(x)
  
  Available functions: sin, cos, tan, log, exp, sqrt, pi, e
  Examples:
    - "3*sin(x) + 2*cos(x)" âœ“
    - "sqrt(x**2 + y**2)" âœ“
    - "pi * r**2" âœ“ (circle area)

LATEX SYNTAX (for equations/displays):
  CRITICAL: Double-escape all backslashes in JSON strings
  Ã— INVALID: "\frac{1}{2}"
  âœ“ VALID: "\\frac{1}{2}"
  
  Examples:
    - "\\frac{dy}{dx} = \\int_0^\\infty f(x) dx" âœ“
    - "\\sqrt{\\Delta} = \\sqrt{b^2 - 4ac}" âœ“
    - "\\pi r^2" âœ“

6.5 VOICEOVER & TTS RULES (PHONETIC SPELLING)
-------------------------------------------
The voiceover field is read by Text-To-Speech system. NEVER use raw symbols.

MANDATORY PHONETIC SUBSTITUTIONS:

Mathematical/Scientific Terms:
  Ï€ (pi) â†’ "pie" or "pi"
  sin(x) â†’ "sine of x" (NOT "sine x")
  cos(x) â†’ "cosine of x"
  tan(x) â†’ "tangent of x"
  dy/dx â†’ "d y d x" OR "the derivative of y with respect to x"
  âˆ« â†’ "integral" (NOT "int")
  Î£ â†’ "sum" OR "summation"
  âˆ‡ â†’ "del" OR "gradient"
  âˆš â†’ "square root"
  |x| â†’ "absolute value of x" OR "mod x"

Variables & Notation:
  x_1 â†’ "x sub one"
  x_n â†’ "x sub n"
  aÂ² â†’ "a squared"
  aÂ³ â†’ "a cubed"
  aâ¿ â†’ "a to the power n"
  f(x) â†’ "f of x"
  fâˆ˜g â†’ "f composed with g"

Units & Constants:
  m/sÂ² â†’ "meters per second squared"
  kgÂ·m/sÂ² â†’ "kilogram meters per second squared"
  J (Joules) â†’ "joules" (NOT "jule")
  Hz (Hertz) â†’ "hertz"
  h-bar â†’ "h bar" (Planck constant)

Statistical Terms:
  Î¼ (mu) â†’ "mew"
  Ïƒ (sigma) â†’ "sigma"
  Var(X) â†’ "variance of X"
  SD â†’ "standard deviation"
  P(A|B) â†’ "probability of A given B"
  z-score â†’ "z score"
  CI â†’ "confidence interval"

Chemistry & Physics:
  Hâ‚‚O â†’ "H two O" OR "water"
  Hâ‚‚SOâ‚„ â†’ "H two S O four" OR "sulfuric acid"
  C-14 â†’ "carbon fourteen"
  eâ» â†’ "electron"
  Ïƒ bond â†’ "sigma bond"
  Ï€ bond â†’ "pi bond"
  HOMO/LUMO â†’ "H O M O" / "L U M O"
  IR spectroscopy â†’ "infrared spectroscopy"
  NMR â†’ "N M R"

Other Abbreviations:
  GDP â†’ "G D P"
  USD â†’ "U S dollars"
  ROI â†’ "R O I"
  DNA â†’ "D N A"
  RNA â†’ "R N A"
  ATP â†’ "A T P"
  PDF â†’ "P D F"
  CDF â†’ "C D F"

CRITICAL: Never write mathematical expressions directly in voiceover:
  âœ— "The value of Ï€ is 3.14"
  âœ“ "The value of pi is three point one four"
  
  âœ— "dy/dx equals zero at the critical point"
  âœ“ "d y d x equals zero at the critical point"

6.5.1 GREEK ALPHABET SYMBOLS (FAMOUS MATHEMATICAL/SCIENTIFIC NOTATION)
--------------------------------------------------------------------
The LLM automatically uses Greek symbols in animations for accuracy and
scientific rigor. This section specifies how they appear visually, how to
pronounce them, and in which contexts they're typically used.

COMPLETE GREEK ALPHABET WITH USAGE:

LOWERCASE GREEK LETTERS:
  Î± (alpha)        â†’ "alpha"       | Used in: angles, significance levels, constants
    LaTeX: \\alpha
    Example equation: E = Î±Â·xÂ² (energy coefficient)
    Voiceover: "alpha x squared"
    
  Î² (beta)         â†’ "beta"        | Used in: regression coefficients, angles
    LaTeX: \\beta
    Example equation: y = Î²â‚€ + Î²â‚x (linear regression)
    Voiceover: "beta zero plus beta one x"
    
  Î³ (gamma)        â†’ "gamma"       | Used in: Lorentz factor, heat capacity ratio
    LaTeX: \\gamma
    Example equation: Î³ = 1/âˆš(1-vÂ²/cÂ²) (Lorentz factor)
    Voiceover: "gamma equals one over square root of one minus v squared over c squared"
    Famous: Einstein's relativity (special relativity)
    
  Î´ (delta)        â†’ "delta"       | Used in: small changes, Dirac delta, variation
    LaTeX: \\delta
    Example equation: Î´E/Î´t (energy change over time)
    Voiceover: "delta E over delta t"
    
  Î” (Delta)        â†’ "capital delta" | Used in: finite differences, change in quantity
    LaTeX: \\Delta
    Example equation: Î”T = T_final - T_initial
    Voiceover: "delta T equals T final minus T initial"
    
  Îµ (epsilon)      â†’ "epsilon"     | Used in: small numbers, strain, permittivity
    LaTeX: \\epsilon
    Example equation: Îµ = E/Ïƒ (strain from stress)
    Voiceover: "epsilon equals E over sigma"
    
  Î¶ (zeta)         â†’ "zeta"        | Used in: Riemann zeta function, damping ratio
    LaTeX: \\zeta
    Example equation: Î¶(s) = Î£(1/n^s) (Riemann zeta)
    Voiceover: "zeta of s equals the summation of one over n to the power s"
    
  Î· (eta)          â†’ "eta"         | Used in: efficiency, viscosity, gravitational waves
    LaTeX: \\eta
    Example equation: Î· = P_out / P_in (thermal efficiency)
    Voiceover: "eta equals power out over power in"
    
  Î¸ (theta)        â†’ "theta"       | Used in: angles, temperature, phase
    LaTeX: \\theta
    Example equation: T = Tâ‚€ cos(Î¸) (temperature distribution)
    Voiceover: "T equals T zero cosine of theta"
    
  Î¹ (iota)         â†’ "iota"        | Less common; used in complex analysis
    LaTeX: \\iota
    
  Îº (kappa)        â†’ "kappa"       | Used in: curvature, thermal conductivity
    LaTeX: \\kappa
    Example equation: Îºâˆ‡Â²T = âˆ‚T/âˆ‚t (heat diffusion)
    Voiceover: "kappa del squared T equals partial T partial t"
    
  Î» (lambda)       â†’ "lambda"      | Used in: wavelength, eigenvalues, decay constant
    LaTeX: \\lambda
    Example equation: Î» = c/f (wavelength from frequency)
    Voiceover: "lambda equals c over f"
    Famous: Bragg's law (X-ray diffraction)
    
  Î¼ (mu)           â†’ "mew"         | Used in: mean, permeability, friction coefficient
    LaTeX: \\mu
    Example equation: Î¼_k = F_k / N (kinetic friction coefficient)
    Voiceover: "mew k equals F k over N"
    
  Î½ (nu)           â†’ "new" / "noo" | Used in: frequency, Poisson's ratio, viscosity
    LaTeX: \\nu
    Example equation: f = c/Î» where Î½ is frequency
    Voiceover: "new equals c over lambda"
    
  Î¾ (xi)           â†’ "zigh" / "zee" | Used in: correlation, probability
    LaTeX: \\xi
    
  Î¿ (omicron)      â†’ "om-i-kron"   | Rarely used; similar to O
    LaTeX: \\omicron
    
  Ï€ (pi)           â†’ "pie"         | Used in: circles, periodic functions, mathematical constant
    LaTeX: \\pi
    Example equation: A = Ï€rÂ² (circle area)
    Voiceover: "pie r squared"
    Famous: Most iconic mathematical constant
    Value: Ï€ â‰ˆ 3.14159265...
    
  Ï (rho)          â†’ "row"         | Used in: density, resistance, correlation
    LaTeX: \\rho
    Example equation: Ï = m/V (density from mass and volume)
    Voiceover: "rho equals m over V"
    
  Ïƒ (sigma)        â†’ "sigma"       | Used in: summation (Î£), standard deviation, surface tension
    LaTeX: \\sigma (lowercase) or \\Sigma (uppercase)
    Example equation: Ïƒ = âˆš(Î£(xáµ¢ - Î¼)Â² / N)  (standard deviation)
    Voiceover: "sigma equals square root of summation of x i minus mew squared over N"
    
  Î£ (Sigma)        â†’ "summation" / "capital sigma" | Used in: summation operator
    LaTeX: \\Sigma
    Example equation: Î£áµ¢â‚Œâ‚â¿ i = n(n+1)/2
    Voiceover: "summation from i equals one to n of i equals n times n plus one over two"
    
  Ï„ (tau)          â†’ "tau"         | Used in: torque, time constant, tangential stress
    LaTeX: \\tau
    Example equation: Ï„ = r Ã— F (torque from position and force)
    Voiceover: "tau equals r cross F"
    
  Ï… (upsilon)      â†’ "up-si-lon"   | Used in: energy levels (rare)
    LaTeX: \\upsilon
    
  Ï† (phi)          â†’ "fee" / "figh" | Used in: angles, probability distributions, phase
    LaTeX: \\phi
    Example equation: Ï† = Ï‰t + Ï†â‚€ (phase angle in waves)
    Voiceover: "phi equals omega t plus phi zero"
    
  Ï‡ (chi)          â†’ "kai"         | Used in: chi-squared test, magnetic susceptibility
    LaTeX: \\chi
    Example equation: Ï‡Â² = Î£((O-E)Â²/E) (chi-squared statistic)
    Voiceover: "chi squared equals summation of observed minus expected squared over expected"
    
  Ïˆ (psi)          â†’ "sigh" / "psigh" | Used in: wave function (quantum mechanics), percentile
    LaTeX: \\psi
    Example equation: Î¨(x,t) = Ae^i(kx-Ï‰t) (quantum wave function)
    Voiceover: "psi of x t equals A e to the power i k x minus omega t"
    Famous: SchrÃ¶dinger equation
    
  Ï‰ (omega)        â†’ "oh-may-gah"  | Used in: angular frequency, probability space
    LaTeX: \\omega
    Example equation: f = Ï‰ / 2Ï€ (frequency from angular frequency)
    Voiceover: "f equals omega over two pi"

UPPERCASE GREEK LETTERS (Used for emphasis/importance):
  Î‘ (Alpha)   â†’ "capital alpha"  | LaTeX: \\mathrm{A} (or formal context uses capital)
  Î’ (Beta)    â†’ "capital beta"   | LaTeX: \\mathrm{B}
  Î“ (Gamma)   â†’ "capital gamma"  | LaTeX: \\Gamma
  Î” (Delta)   â†’ "capital delta"  | LaTeX: \\Delta | Change in quantity
  Î• (Epsilon) â†’ "capital epsilon"| LaTeX: \\mathrm{E}
  Î˜ (Theta)   â†’ "capital theta"  | LaTeX: \\Theta | Phase in frequency domain
  Î› (Lambda)  â†’ "capital lambda" | LaTeX: \\Lambda
  Îž (Xi)      â†’ "capital xi"     | LaTeX: \\Xi
  Î  (Pi)      â†’ "capital pi"     | LaTeX: \\Pi | Product operator
  Î£ (Sigma)   â†’ "summation"      | LaTeX: \\Sigma | Sum operator
  Î¥ (Upsilon) â†’ "capital upsilon"| LaTeX: \\Upsilon
  Î¦ (Phi)     â†’ "capital phi"    | LaTeX: \\Phi
  Î¨ (Psi)     â†’ "capital psi"    | LaTeX: \\Psi | Wave function
  Î© (Omega)   â†’ "capital omega"  | LaTeX: \\Omega | Ohms (electrical resistance)

MATHEMATICAL OPERATOR SYMBOLS (FAMOUS IN SCIENTIFIC NOTATION):

Integration & Summation:
  âˆ« (Integral)    â†’ "integral"
    LaTeX: \\int
    Example: âˆ«â‚€^âˆž e^(-x) dx = 1
    Voiceover: "integral from zero to infinity of e to the power negative x d x equals one"
    Famous: Calculus foundation
    
  âˆ‘ (Summation)   â†’ "summation" / "sum"
    LaTeX: \\sum
    Example: Î£áµ¢â‚Œâ‚€â¿ i = n(n+1)/2
    Voiceover: "summation from i equals zero to n of i equals n times n plus one over two"
    
  âˆ (Product)     â†’ "product"
    LaTeX: \\prod
    Example: Î áµ¢â‚Œâ‚â¿ i = n!
    Voiceover: "product from i equals one to n of i equals n factorial"

Calculus Operators:
  âˆ‡ (Nabla/Del)        â†’ "del" / "gradient"
    LaTeX: \\nabla
    Example: âˆ‡T = temperature gradient
    Voiceover: "del T" or "gradient of T"
    
  âˆ‚ (Partial)          â†’ "partial"
    LaTeX: \\partial
    Example: âˆ‚T/âˆ‚t = temperature change over time
    Voiceover: "partial T partial t"
    
  âˆ‡Â² (Laplacian)       â†’ "del squared" / "laplacian"
    LaTeX: \\nabla^2
    Example: âˆ‡Â²u = f (Poisson equation)
    Voiceover: "del squared u equals f"

Set & Logic Operators:
  âˆˆ (Element of)       â†’ "element of"
    LaTeX: \\in
    Example: x âˆˆ â„
    Voiceover: "x is an element of real numbers"
    
  âŠ‚ (Subset of)        â†’ "subset of"
    LaTeX: \\subset
    
  âˆª (Union)            â†’ "union"
    LaTeX: \\cup
    
  âˆ© (Intersection)     â†’ "intersection"
    LaTeX: \\cap
    
  âˆ… (Empty set)        â†’ "empty set"
    LaTeX: \\emptyset
    
  âˆž (Infinity)         â†’ "infinity"
    LaTeX: \\infty
    Example: lim(xâ†’âˆž) 1/x = 0
    Voiceover: "limit as x approaches infinity of one over x equals zero"

Relationship Operators:
  â‰ˆ (Approximately equal) â†’ "approximately equal to"
    LaTeX: \\approx
    Example: Ï€ â‰ˆ 3.14159
    Voiceover: "pi is approximately equal to three point one four one five nine"
    
  â‰  (Not equal)         â†’ "not equal to"
    LaTeX: \\neq
    
  â‰¤ (Less than or equal)â†’ "less than or equal to"
    LaTeX: \\leq
    
  â‰¥ (Greater than or equal) â†’ "greater than or equal to"
    LaTeX: \\geq
    
  âˆ (Proportional to)   â†’ "proportional to"
    LaTeX: \\propto
    Example: F âˆ ma
    Voiceover: "F is proportional to m times a"

PHYSICS CONSTANTS & SPECIAL SYMBOLS:

  â„ (h-bar)             â†’ "h bar" / "reduced Planck constant"
    LaTeX: \\hbar
    Value: â„ = h / 2Ï€ â‰ˆ 1.055 Ã— 10â»Â³â´ JÂ·s
    Example: E = â„Ï‰ (energy from angular frequency)
    Voiceover: "E equals h bar omega"
    Famous: Quantum mechanics (Planck constant)
    
  â„¶ (Aleph)             â†’ "aleph"
    LaTeX: \\aleph
    Used in: infinity theory, cardinality
    
  â„® (German ÃŸ)          â†’ "ess-tset" / "German S"
    Used in: German words in chemistry
    LaTeX: \\ss
    
EXAMPLE: FAMOUS EQUATIONS WITH GREEK SYMBOLS

Equation 1: Einstein's Mass-Energy Equivalence
  Visual: E = mcÂ²
  With Greek: Sometimes written as E = mÎ³cÂ² (relativistic form)
  Voiceover: "E equals m c squared" OR "E equals gamma m c squared in relativistic form"
  Significance: Foundation of modern physics

Equation 2: SchrÃ¶dinger Equation
  Visual: iâ„ âˆ‚Î¨/âˆ‚t = -â„Â²/2m âˆ‡Â²Î¨ + VÎ¨
  Voiceover: "i h bar partial psi partial t equals negative h bar squared over two m 
             times del squared psi plus V psi"
  Significance: Quantum mechanics governing wave functions
  
Equation 3: Hardy-Weinberg Equilibrium
  Visual: pÂ² + 2pq + qÂ² = 1
  With symbols: pÂ² + 2pq + qÂ² = 1 (where p, q are allele frequencies)
  Voiceover: "p squared plus two p q plus q squared equals one"
  Significance: Population genetics

Equation 4: Exponential Decay
  Visual: N(t) = Nâ‚€e^(-Î»t)
  Voiceover: "N of t equals N zero e to the power negative lambda t"
  Where Î» = decay constant
  Significance: Radioactivity, half-life calculations

Equation 5: Fourier Transform
  Visual: F(Ï‰) = âˆ«â‚‹âˆž^âˆž f(t)e^(-iÏ‰t) dt
  Voiceover: "capital F of omega equals the integral from negative infinity to positive 
             infinity of f of t times e to the power negative i omega t d t"
  Significance: Signal processing, frequency analysis

6.5.2 AUTOMATIC SYMBOL RENDERING IN ANIMATIONS
---------------------------------------------
The LLM AUTOMATICALLY selects and displays Greek symbols when:

TRIGGER 1: Physics/Mathematics Domain Detected
  IF question contains: "wave", "quantum", "frequency", "decay", "integration"
  THEN use appropriate Greek symbols (Ïˆ, Ï‰, Î», âˆ«, etc.)

TRIGGER 2: Standard Formula Recognition
  IF LLM recognizes famous equation (Einstein, SchrÃ¶dinger, Maxwell, etc.)
  THEN render with original/canonical symbols

TRIGGER 3: Statistical Analysis
  IF problem involves: statistics, distributions, significance
  THEN use Ïƒ (standard deviation), Î¼ (mean), Ï‡Â² (chi-squared), etc.

TRIGGER 4: Regular Expressions in Solution
  IF solution step includes: angles, changes, limits
  THEN automatically substitute: Î¸ for angles, Î” for changes, lim for limits

SYMBOL SELECTION ALGORITHM:

```python
class SymbolRenderer:
    def __init__(self):
        self.symbol_map = {
            'wavelength': 'Î»',
            'frequency': 'Î½',
            'angular_frequency': 'Ï‰',
            'decay_constant': 'Î»',
            'standard_deviation': 'Ïƒ',
            'mean': 'Î¼',
            'angle': 'Î¸',
            'change': 'Î”',
            'partial': 'âˆ‚',
            'integral': 'âˆ«',
            'summation': 'Î£',
            'product': 'Î ',
            'gradient': 'âˆ‡',
            'infinity': 'âˆž',
            'empty_set': 'âˆ…',
            'element_of': 'âˆˆ',
            'proportional': 'âˆ',
            'approximately': 'â‰ˆ'
        }
    
    def render_symbol_in_latex(self, concept, value):
        """Convert concept to appropriate Greek symbol in LaTeX"""
        if concept in self.symbol_map:
            symbol = self.symbol_map[concept]
            latex_code = self.convert_to_latex(symbol)
            return latex_code
        return value
    
    def convert_to_latex(self, symbol):
        """Map symbol to LaTeX representation"""
        latex_map = {
            'Î»': '\\lambda',
            'Î½': '\\nu',
            'Ï‰': '\\omega',
            'Ïƒ': '\\sigma',
            'Î¼': '\\mu',
            'Î¸': '\\theta',
            'Î”': '\\Delta',
            'âˆ‚': '\\partial',
            'âˆ«': '\\int',
            'Î£': '\\Sigma',
            'Î ': '\\Pi',
            'âˆ‡': '\\nabla',
            'âˆž': '\\infty',
            'âˆ…': '\\emptyset',
            'âˆˆ': '\\in',
            'âˆ': '\\propto',
            'â‰ˆ': '\\approx'
        }
        return latex_map.get(symbol, symbol)
    
    def generate_voiceover_text(self, latex_expr):
        """Convert LaTeX expression to phonetic voiceover"""
        # Replace Greek letter LaTeX with phonetic spellings
        voiceover = latex_expr
        voiceover = voiceover.replace('\\lambda', 'lambda')
        voiceover = voiceover.replace('\\omega', 'omega')
        voiceover = voiceover.replace('\\nu', 'new')
        voiceover = voiceover.replace('\\sigma', 'sigma')
        voiceover = voiceover.replace('\\mu', 'mew')
        voiceover = voiceover.replace('\\theta', 'theta')
        # ... more replacements
        return voiceover
```

COLOR CODING FOR GREEK SYMBOLS (Optional):
  To enhance visual clarity, Greek symbols can be color-coded by domain:
  
  Physics Constants:
    Ï€, â„, c, G â†’ Display in BLUE (#0000FF)
    Example: "The constant h bar is shown in blue"
  
  Mathematical Operators:
    âˆ«, Î£, âˆ, âˆ‡, âˆ‚ â†’ Display in GREEN (#00FF00)
    Example: "The integral symbol appears in green"
  
  Variables/Parameters:
    Î», Ï‰, Î¸, Ïƒ, Î¼ â†’ Display in YELLOW (#FFFF00)
    Example: "Lambda wavelength is highlighted in yellow"
  
  Comparison/Logic:
    âˆˆ, âŠ‚, âˆª, âˆ©, â‰ˆ â†’ Display in RED (#FF0000)
    Example: "The approximately equal symbol is red"

6.6 ANIMATION ELEMENT TYPES
---------------------------
Supported element types in the animation_plan:

1. TEXT ELEMENTS
   {
     "type": "Text",
     "content": "Velocity v(t)",
     "position": "[0, 3, 0]",
     "style": {"color": "#FFFFFF", "font_size": 48},
     "timing": {"transition_in": "Write", "duration_in": 1.0}
   }

2. EQUATIONS (Latex/MathTex)
   {
     "type": "MathTex",
     "content": "\\int_0^\\infty e^{-x^2} dx = \\frac{\\sqrt{\\pi}}{2}",
     "position": "[0, 0, 0]",
     "timing": {"transition_in": "Write"}
   }

3. COORDINATE AXES (for graphs)
   {
     "type": "Axes",
     "position": "[-2, -1, 0]",
     "style": {
       "x_range": [-5, 5, 1],      // [min, max, step]
       "y_range": [-3, 3, 1],
       "x_label": "Time (t)",
       "y_label": "Position (m)",
       "color": "#888888"
     }
   }

4. FUNCTION GRAPHS
   {
     "type": "Graph",
     "content": "sin(x) * x",        // Python syntax
     "style": {
       "color": "#00FF00",
       "x_range": [-5, 5],
       "label": "f(x) = x sin(x)"
     }
   }

5. PARAMETRIC CURVES (circles, spirals)
   {
     "type": "Graph",
     "style": {
       "mode": "parametric",
       "x": "3*cos(t)",             // x(t)
       "y": "3*sin(t)",             // y(t)
       "t_range": [0, 6.283],       // 0 to 2Ï€
       "color": "#FFFF00"
     }
   }

6. GEOMETRIC SHAPES
   {
     "type": "Polygon|Circle|Rectangle|Line|Arrow",
     "content": "[(0,0), (2,0), (1,1.732)]",  // For Polygon
     "style": {
       "color": "#FF00FF",
       "fill_opacity": 0.5,
       "stroke_width": 4
     }
   }

7. VECTOR FIELDS
   {
     "type": "VectorField",
     "content": "[-y, x]",           // [dx/dt, dy/dt]
     "style": {"color": "#0000FF"}
   }

6.7 SCENE CONSTRUCTION & TIMING RULES
------------------------------------
CHRONOLOGICAL ORDER:
  Scenes execute sequentially in the order listed in animation_plan.scenes[]

AUDIO SYNCHRONIZATION:
  The voiceover is the master clock. Element timing must align with speech.
  
  Example:
    voiceover: "Here we see the circle, followed by the square."
    circle: timing.start = 0.0
    square: timing.start = 2.0 (delayed until "square" is mentioned)

TRANSITION TYPES:
  â€¢ Create: Best for lines, graphs, shapes (draws gradually)
  â€¢ Write: Best for text and equations (handwriting effect)
  â€¢ FadeIn: Best for images or dense layouts (transparency fade)
  â€¢ GrowFromCenter: Good for impactful shapes (expansion animation)
  â€¢ FadeOut: Remove element smoothly
  â€¢ Uncreate: Reverse of Create (object erases)

ADAPTIVE PACING:
  Duration should match complexity:
  
  Simple Step (single formula): 2-3 seconds
    â€¢ Elements: 1-3
    â€¢ Voiceover: ~5-8 words
    â€¢ Example: "This is the quadratic formula"
  
  Moderate Step (1-2 visualizations): 3.5-5 seconds
    â€¢ Elements: 4-7
    â€¢ Voiceover: ~15-25 words
  
  Complex Step (multi-part proof, graph): 5.5-8 seconds
    â€¢ Elements: 8+ (split if necessary)
    â€¢ Voiceover: ~40-50 words
  
  Very Complex Step (full derivation): 8.5-12 seconds
    â€¢ Multiple graphs, 3D visualization
    â€¢ Voiceover: ~60-80 words

VOICEOVER DURATION CALCULATION:
  â€¢ Average speech rate: ~150 words per minute
  â€¢ Equivalent: ~2.5 words per second
  â€¢ Formula: duration (seconds) = word_count / 2.5
  
  Example:
    50-word voiceover â†’ 50/2.5 = 20 seconds needed

CLEANUP:
  â€¢ Objects persist on screen until explicitly removed
  â€¢ Use transition_out: "FadeOut" to remove elements
  â€¢ Start new Scene if current one becomes crowded (>8 elements)

6.8 STEP SEQUENCING REQUIREMENTS
-------------------------------
MANDATORY CONSTRAINTS:

1. COMPLETE COVERAGE
   Every step in solution.steps[] MUST map to at least one scene
   OR one element in animation_plan
   
   Example Error (INVALID):
     solution.steps includes "Apply Chain Rule"
     animation_plan has NO scene/element mentioning chain rule
   
   FIXED: Add explicit scene with chain rule visualization

2. EXPLICIT ORDERING
   Steps MUST follow logical progression:
   - Prerequisites before applications
   - Definitions before usage
   - Simple before complex
   
   Example (VALID):
     Step 1: Define derivative
     Step 2: State power rule formula
     Step 3: Apply power rule to specific function
     Step 4: Verify answer

3. VOICEOVER-VISUAL ALIGNMENT
   Every solution step MUST be narrated in some scene voiceover
   
   Example:
     solution.steps[2].title = "Apply the Power Rule"
     scene[2].voiceover MUST mention "apply" AND "power rule"

4. NO REDUNDANCY
   Don't explain the same concept twice
   Exception: Recap sections (must be labeled as such)
   
   Example Error:
     Scene 1 voiceover: "The chain rule states..."
     Scene 3 voiceover: "The chain rule states..." (same explanation)
   
   FIXED: Merge into one scene OR label Scene 3 as "Recap"

5. LOGICAL DEPENDENCIES
   Explicitly state dependencies between steps
   
   Example:
     Step 3 depends on results from Steps 1-2
     Animation must show Step 1 â†’ Step 2 â†’ Step 3 in order

6.9 COLLISION DETECTION & LAYOUT MANAGEMENT
-----------------------------------------
PROBLEM: Text overlaps with graphs, reducing readability

SOLUTION: Automatic layout engine with multiple strategies

LAYOUT STRATEGIES:

1. SIDE-BY-SIDE (Default for text + graph)
   Graph: [-3.5, 0, 0] (left)
   Text: [3.5, 0, 0] (right)
   Spacing: 1.0 unit minimum gap

2. STACKED (For vertical content)
   Title: [0, 3.0, 0] (top)
   Content: [0, 0, 0] (middle)
   Explanation: [0, -2.5, 0] (bottom)

3. FLOATING (Free positioning)
   Automatic collision resolution
   Intelligent repositioning to avoid overlaps

4. CENTERED (Single main element)
   Element: [0, 0, 0]
   Text labels offset by Â±1.5 in Y

5. GRID (Multiple independent elements)
   4-element grid: 4 quadrants of screen

COLLISION RESOLUTION ALGORITHM:
  1. Compute bounding boxes for all elements
  2. Detect overlaps using AABB (Axis-Aligned Bounding Box)
  3. If overlap detected:
     a. Calculate separation distance needed
     b. Move smaller element away
     c. Recompute bounding boxes
     d. Repeat until no overlaps
  4. Verify all elements within screen bounds [-6.6, +6.6] X [-3.5, +3.5]

TARGET METRIC: Overlap Ratio (OR) â‰¥ 0.95
  (Less than 5% of frames should have overlaps)

LAYER MANAGEMENT (Z-INDEX):
  Priority order (back to front):
  â€¢ Background (z = 0-10): Textures, patterns
  â€¢ Content (z = 11-50): Graphs, diagrams, figures
  â€¢ Text (z = 51-100): Labels, equations, captions
  â€¢ Annotations (z = 101-200): Highlights, arrows, boxes

Automatic Assignment:
  Text elements â†’ z = 75
  Graphs/Figures â†’ z = 30
  Annotations/Arrows â†’ z = 150

READABILITY INDEX (RI):
  Measures: Font size + Color contrast + Spacing
  Target: RI â‰¥ 0.9
  
  Actions if RI < 0.9:
  âœ“ Increase font size (minimum 12pt, recommended 18-28pt)
  âœ“ Improve color contrast (dark on light, OR light on dark)
  âœ“ Increase spacing between elements
  âœ“ Add semi-transparent background behind text

6.10 ERROR PREVENTION & VALIDATION CHECKLIST
-------------------------------------------
Before outputting JSON, verify against these 250+ error checks:

CRITICAL CHECKLIST (MUST PASS):
  â˜ All JSON syntax valid, no unescaped characters
  â˜ All steps covered by animation (01-275)
  â˜ No mathematical errors (PEMDAS, units, definitions)
  â˜ Voiceover uses only phonetic spelling (no raw symbols)
  â˜ All LaTeX properly double-escaped
  â˜ No coordinate violations (within [-7.1, +7.1] X [-4.0, +4.0])
  â˜ No overlap of critical elements (OR â‰¥ 0.95)
  â˜ Timing matches complexity (pacing rule compliance)
  â˜ Voiceover duration â‰¤ scene duration
  â˜ Step ordering is logical (no circular dependencies)

ERROR CATEGORIES (Total: 250+):
  â€¢ Mathematical & Logical (1-50): Order of operations, algebra, calculus
  â€¢ Pedagogical Structure (51-75): Pacing, prerequisites, narrative
  â€¢ Animation Content (76-105): Physics realism, geometry, diagrams
  â€¢ Manim Specific (106-125): LaTeX, animation classes, Python syntax
  â€¢ Voiceover & Script (126-150): Grammar, pronunciation, tone
  â€¢ Object Creation (151-170): Shapes, colors, styling
  â€¢ Animation Details (171-195): Transforms, rotations, timing
  â€¢ Timing & Sequencing (196-210): Scene duration, pacing, layers
  â€¢ TTS & Audio (211-225): Pronunciation, prosody, sound quality
  â€¢ System Integration (226-250): Sync, format, compatibility
  â€¢ Step Sequencing (251-275): Coverage, ordering, dependencies
  â€¢ Pacing & Timing (276-290): Adaptive duration, voiceover matching
  â€¢ Redundancy (291-310): Repetition, content drift, clarity

6.11 INTEGRATION WITH FINE-TUNING WORKFLOW
-----------------------------------------
PIPELINE INTEGRATION:

STEP 1: User submits question
  User Input: "How do I solve a quadratic equation?"

STEP 2: LLM processes with domain restrictions
  Fine-tuned model: "This is a Mathematics question. âœ“ IN-DOMAIN"
  Response with Wikipedia enrichment (optional)

STEP 3: Solution generation
  LLM outputs solution.steps with detailed explanations

STEP 4: Animation planning
  Manim prompt system converts solution to animation JSON
  Apply all validation checks (250+)
  Resolve overlaps and placement issues

STEP 5: Rendering
  Manim library processes JSON
  Generates high-quality video with synchronized audio

STEP 6: Delivery
  Video served to learner with synchronized text steps
  Wikipedia context cards displayed alongside

6.12 EXAMPLE: QUADRATIC EQUATION SOLUTION
-----------------------------------
DETAILED EXAMPLE showing all components:

USER QUERY:
  "How do you solve 2xÂ² + 3x + 1 = 0?"

FINE-TUNED LLM RESPONSE (solution part):
  topic: "Algebra: Quadratic Formula"
  steps: [
    {
      title: "Identify coefficients",
      explanation: "From the equation 2xÂ² + 3x + 1 = 0, we have a=2, b=3, c=1",
      latex: "ax^2 + bx + c = 0; a=2, b=3, c=1"
    },
    {
      title: "State the quadratic formula",
      explanation: "Use x = (-b Â± âˆš(bÂ²-4ac)) / 2a",
      latex: "x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}"
    },
    ...
  ]

MANIM ANIMATION PLAN:
  Scene 1: Introduce equation
    voiceover: "We need to solve two x squared plus three x plus one equals zero"
    elements: [
      {type: "MathTex", content: "2x^2 + 3x + 1 = 0", position: "[0, 2, 0]"},
      {type: "Text", content: "Identify coefficients", position: "[0, 0.5, 0]"}
    ]
  
  Scene 2: Quadratic formula
    voiceover: "We use the quadratic formula: x equals negative b plus or minus 
               square root of b squared minus four times a times c, all divided by 
               two times a"
    elements: [
      {type: "MathTex", content: "x = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}", 
       position: "[0, 0, 0]"}
    ]
  ...

================================================================================
7. QUALITY ASSURANCE & PERFORMANCE METRICS
================================================================================

COMPREHENSIVE METRICS DASHBOARD:

Metric 1: DOMAIN ACCURACY (DA)
  Target: >95%
  Measurement: % of responses within Physics/Math/Chemistry/Economics
  Calculation: (In-domain questions answered correctly) / (Total questions)

Metric 2: STEP COMPLETENESS (SC)
  Target: 100%
  Measurement: % of solutions showing all intermediate steps
  Calculation: (Animations with â‰¥ expected steps) / (Total animations)

Metric 3: OVERLAP RATIO (OR)
  Target: â‰¥0.95 (â‰¤5% frames with overlap)
  Measurement: % of frames with NO text-graph overlap
  Calculation: (Frames without collision) / (Total frames)

Metric 4: READABILITY INDEX (RI)
  Target: â‰¥0.9
  Components: Font size (18-48pt) + Contrast (WCAG AA) + Spacing (0.5+ units)

Metric 5: TIMING ACCURACY (TA)
  Target: â‰¥0.9 (Â±0.2 second tolerance)
  Measurement: Text appearance timing vs. voiceover narration
  Calculation: (Properly-timed elements) / (Total elements)

Metric 6: LAYER ACCURACY (LA)
  Target: 100% (all elements on correct z-order)
  Measurement: Visual hierarchy correctness
  Calculation: (Correct z-index assignments) / (Total elements)

Metric 7: USER SATISFACTION
  Target: â‰¥4.5 / 5.0 stars
  Measurement: Post-video feedback survey
  Components: Clarity, Engagement, Helpfulness, Pacing

Metric 8: PERFORMANCE
  Target: <2 seconds per problem resolution
  Measurement: End-to-end latency
  Components: LLM inference + Animation planning + Rendering

DEPLOYMENT READINESS CHECKLIST:
  â˜ DA â‰¥ 95%, average SD â‰¤ 5%
  â˜ SC = 100% across all problem types
  â˜ OR â‰¥ 0.95, no critical overlaps
  â˜ RI â‰¥ 0.9, readability verified by user testing
  â˜ TA â‰¥ 0.9, timing variance documented
  â˜ LA = 1.0, visual hierarchy perfect
  â˜ User satisfaction â‰¥ 4.5, feedback incorporated
  â˜ Performance <2s, load testing passed
  â˜ All 250+ error checks passing
  â˜ Wikipedia enrichment validated (accuracy >95%)
  â˜ Step sequencing tested with 100+ problems
  â˜ Collision detection verified visually
  â˜ Documentation complete and reviewed
  â˜ Production deployment approved by technical review

================================================================================
8. UNIVERSAL LESSON SCRIPT TEMPLATE (INTRO & OUTRO DIALOGUES)
================================================================================

OVERVIEW:
  The LLM generates responses with a three-part structure:
  1. INTRO DIALOGUE: Sets context, builds interest, introduces concepts
  2. CORE SOLUTION: Step-by-step problem solving (unaltered)
  3. OUTRO DIALOGUE: Summarizes, connects to real life, encourages thinking

  The intro/outro dialogues are pedagogically designed to enhance engagement
  without interfering with the mathematical accuracy of the solution.

8.1 RESPONSE STRUCTURE
--------------------
Every LLM response MUST follow this structure:

SEGMENT A: INTRO DIALOGUE (1-2 minutes of voiceover)
  Purpose: Hook learner, introduce topic, establish context
  
SEGMENT B: CORE SOLUTION (Variable duration based on complexity)
  Purpose: Deliver rigorous step-by-step explanation
  Contains: Solution steps, equations, calculations, verification
  NOTE: This segment remains UNCHANGED from standard solution format
  
SEGMENT C: OUTRO DIALOGUE (1-2 minutes of voiceover)
  Purpose: Recap, connect to real life, inspire further learning
  
TOTAL RESPONSE TIME: Intro + Core + Outro

8.2 INTRO DIALOGUE TEMPLATE
---------------------------
The intro dialogue follows this exact format:

Opening Engagement:
  "Hello everyone! Ok, today we are going to learn something new. 
   Don't worry, we are not just going to solve questions, we are going to 
   understand why things happen and how they work."

Real-Life Context:
  "First, let's think about what this [TOPIC] is about. 
   Imagine [REAL-LIFE-EXAMPLE related to the topic]. 
   This chapter will help us understand things like this."

Concept Introduction:
  "Now, let's see the main ideas. 
   The first idea is [CONCEPT-1]. 
   The second idea is [CONCEPT-2]. 
   And the third idea is [CONCEPT-3]. 
   But why do we need to know this? Well, these ideas help us see patterns, 
   make decisions, or understand the world around us."

Conceptual Thinking:
  "Before we do any calculations or numbers, let's think about how these 
   ideas work. How does this happen? Why does it happen this way? 
   What if we change something? Asking these questions helps us really 
   understand, not just remember."

Historical Context:
  "Also, it is interesting to know who discovered these ideas. 
   For example, [DISCOVERER-NAME] discovered this concept in [YEAR] 
   because [SHORT-STORY about discovery/motivation]. 
   Ok, imagine being that person, trying to figure out something no one 
   else knew. That's why we study their workâ€”it helps us see how ideas grow."

Real-World Applications:
  "Let's also see how this is useful in real life.
   For Math, it can help in counting, measuring, or making plans.
   For Physics, it can help us understand motion, energy, or electricity.
   For Economics, it can help us understand money, prices, or why people 
   buy and sell things.
   For Chemistry, it can help us understand reactions, materials, and 
   how substances interact."

Transition to Solution:
  "Ok now let's dive into the specific problem you asked about. 
   Keep these ideas in mind as we work through the solution together."

8.3 CORE SOLUTION (UNTOUCHED FORMAT)
-----------------------------------
The core solution keeps its original structure:

SOLUTION COMPONENT:
  - Topic identifier
  - Step-by-step explanation
  - LaTeX equations
  - Final answer with verification

ANIMATION PLAN COMPONENT:
  - Scenes organized by step
  - Voiceover synchronized with visuals
  - Elements positioned without overlap
  - Timing optimized for complexity

CRITICAL: The core solution is NOT modified by intro/outro template.
  Only the wrapper dialogue changes, not the mathematical content.

8.4 OUTRO DIALOGUE TEMPLATE
---------------------------
The outro dialogue follows this exact format:

Summary of Learning:
  "Ok, now let's remember what we learned today. 
   The main points are [KEY-POINT-1], [KEY-POINT-2], and [KEY-POINT-3]. 
   These are the foundations that help us understand similar problems."

Encouragement to Apply:
  "Try to see these ideas in your daily life. 
   Next time you see [OBSERVABLE-PHENOMENON related to topic], 
   ask yourself:
   - Why is this happening?
   - How does it work?
   - What would happen if we changed something?
   And think about the person who first discovered thisâ€”what problem 
   did they solve? Why was it important back then?"

Reflection Questions:
  "Here are some questions to think about:
   - [QUESTION-1]: Deeper understanding
   - [QUESTION-2]: Real-world application
   - [QUESTION-3]: Creative extension"

Inspiration:
  "That's all for today. Keep thinking, asking questions, and 
   trying to connect ideas with real life. Learning is not just about 
   remembering, it's about understanding and imagining. 
   And who knows, maybe one day you will discover something new too!"

Closing:
  "See you in the next lesson!"

8.5 IMPLEMENTATION ALGORITHM
----------------------------
```python
class LessonScriptWrapper:
    def __init__(self):
        self.intro_template = {...}  # Template from 8.2
        self.outro_template = {...}  # Template from 8.4
        self.field_map = {
            'TOPIC': extracted_from_question,
            'REAL_LIFE_EXAMPLE': from_domain_database,
            'CONCEPT_1': solution.steps[0].concept,
            'CONCEPT_2': solution.steps[1].concept,
            'CONCEPT_3': solution.steps[2].concept,
            'DISCOVERER_NAME': from_wikipedia,
            'YEAR': from_wikipedia,
            'SHORT_STORY': synthesized_narrative,
            'KEY_POINT_1': solution.steps[0].conclusion,
            'KEY_POINT_2': solution.steps[1].conclusion,
            'KEY_POINT_3': solution.steps[2].conclusion
        }
    
    def generate_intro_dialogue(self, question, solution):
        """Generate intro dialogue by filling template"""
        filled_intro = self.intro_template
        
        # Extract topic from question
        topic = extract_topic(question)
        filled_intro = filled_intro.replace('[TOPIC]', topic)
        
        # Get real-life example from domain database
        real_life_ex = lookup_real_life_example(topic)
        filled_intro = filled_intro.replace('[REAL-LIFE-EXAMPLE]', real_life_ex)
        
        # Extract key concepts from solution
        for i, step in enumerate(solution.steps[:3]):
            filled_intro = filled_intro.replace(
                f'[CONCEPT-{i+1}]', 
                step.title
            )
        
        # Get historical context from Wikipedia
        discoverer, year, story = get_historical_context(topic)
        filled_intro = filled_intro.replace('[DISCOVERER-NAME]', discoverer)
        filled_intro = filled_intro.replace('[YEAR]', str(year))
        filled_intro = filled_intro.replace('[SHORT-STORY]', story)
        
        return filled_intro
    
    def generate_outro_dialogue(self, solution):
        """Generate outro dialogue by filling template"""
        filled_outro = self.outro_template
        
        # Extract key points from solution conclusions
        key_points = [step.conclusion for step in solution.steps[:3]]
        filled_outro = filled_outro.replace(
            '[KEY-POINT-1], [KEY-POINT-2], [KEY-POINT-3]',
            ', '.join(key_points)
        )
        
        # Generate reflection questions based on solution
        questions = generate_reflection_questions(solution)
        for i, q in enumerate(questions[:3]):
            filled_outro = filled_outro.replace(f'[QUESTION-{i+1}]', q)
        
        return filled_outro
    
    def wrap_response(self, intro, core_solution, outro):
        """Combine all components"""
        full_response = {
            'intro_dialogue': intro,
            'voiceover_intro': convert_to_phonetic(intro),
            'core_solution': core_solution,  # UNCHANGED
            'outro_dialogue': outro,
            'voiceover_outro': convert_to_phonetic(outro),
            'total_duration': estimate_duration(intro) + 
                             estimate_duration(core_solution) + 
                             estimate_duration(outro)
        }
        return full_response
```

8.6 FIELD MAPPING & AUTO-FILL DATABASE
--------------------------------------
For automatic template filling, maintain domain-specific databases:

MATH CHAPTER EXAMPLES:
  Topic: Quadratic Equations
    Real-life: "A ball thrown in the air follows a parabolic path"
    Concepts: [Finding roots, Discriminant, Quadratic formula]
    Discoverer: Bhaskara II (12th century), developed root formula
    Application: Architecture, projectile motion, graph design
    
  Topic: Calculus Derivatives
    Real-life: "Speed of a car changing over time"
    Concepts: [Rate of change, Slope of curve, Tangent line]
    Discoverer: Isaac Newton & Gottfried Leibniz (1670s)
    Application: Physics motion, optimization, economics marginal costs

PHYSICS CHAPTER EXAMPLES:
  Topic: Newton's Laws
    Real-life: "Why does a car accelerate when you press the gas pedal?"
    Concepts: [Force, Mass, Acceleration - F=ma]
    Discoverer: Isaac Newton (1687)
    Application: Vehicle design, space exploration, engineering

  Topic: Quantum Mechanics
    Real-life: "How does electricity flow through a wire atom by atom?"
    Concepts: [Wave-particle duality, SchrÃ¶dinger equation, Superposition]
    Discoverer: Erwin SchrÃ¶dinger (1926)
    Application: Electronics, semiconductors, computing

ECONOMICS CHAPTER EXAMPLES:
  Topic: Supply and Demand
    Real-life: "Why does the price of coffee go up when harvest is bad?"
    Concepts: [Supply curve, Demand curve, Market equilibrium]
    Discoverer: Adam Smith (1776), developed market theory
    Application: Pricing strategy, market analysis, policy making

  Topic: GDP and Growth
    Real-life: "How do economists measure if a country is getting richer?"
    Concepts: [Gross Domestic Product, Growth rate, Standard of living]
    Discoverer: Simon Kuznets (1930s), developed GDP measurement
    Application: Government planning, investment decisions

CHEMISTRY CHAPTER EXAMPLES:
  Topic: Molecular Bonding
    Real-life: "Why does water have special properties compared to other liquids?"
    Concepts: [Covalent bonds, Hydrogen bonds, Molecular structure]
    Discoverer: Linus Pauling (1931), explained chemical bonds
    Application: Material science, drug design, industrial chemistry

  Topic: Thermodynamics
    Real-life: "Why does ice melt faster in warm water?"
    Concepts: [Heat transfer, Entropy, Equilibrium]
    Discoverer: Ludwig Boltzmann (1870s), entropy formula
    Application: Energy engineering, climate science, chemistry reactions

8.7 VOICEOVER GENERATION FOR INTRO/OUTRO
----------------------------------------
The intro and outro dialogues are converted to TTS-compatible voiceover:

PHONETIC CONVERSION RULES:
  Mathematical terms â†’ Spelled out phonetically
  Proper names â†’ Preserve correct pronunciation
  Emphasis markers â†’ Added for key concepts
  Pause markers â†’ Inserted for reflection points

EXAMPLE: Quadratic Equations Intro

Original Template:
  "Hello everyone! Ok, today we are going to learn something new. 
   Don't worry, we are not just going to solve questions, we are going to 
   understand why things happen and how they work. First, let's think about 
   what Quadratic Equations are about. Imagine a ball thrown in the air - 
   it follows a curved path that goes up and then comes down. 
   This chapter will help us understand things like this.
   
   Now, let's see the main ideas. The first idea is Finding the Roots. 
   The second idea is The Discriminant. And the third idea is 
   The Quadratic Formula."

Phonetic Voiceover:
  "Hello everyone! Ok, today we are going to learn something new. 
   Don't worry, we are not just going to solve questions, we are going to 
   understand why things happen and how they work. [pause: 1.5 seconds] 
   First, let's think about what Quadratic Equations are about. 
   Imagine a ball thrown in the air - it follows a curved path that goes 
   up and then comes down. This chapter will help us understand things 
   like this.
   
   [pause: 2.0 seconds]
   Now, let's see the main ideas. The first idea is Finding the Roots. 
   The second idea is The Discriminant. And the third idea is 
   The Quadratic Formula. But why do we need to know this? 
   Well, these ideas help us see patterns, make decisions, or understand 
   the world around us."

TIMING GUIDELINES FOR VOICEOVER:
  Intro voiceover: 60-90 words (24-36 seconds at 2.5 words/second)
  Outro voiceover: 60-90 words (24-36 seconds)
  Pauses: 1-2 seconds between major thought units
  Total intro + outro: ~50-75 seconds

8.8 INTEGRATION WITH ANIMATION PLAN
----------------------------------
The intro/outro dialogues are rendered as separate animation scenes:

SCENE: intro_dialogue
  Duration: 24-36 seconds
  Elements:
    - [Text] Title of chapter/topic (top center)
    - [Text] Real-life context (right side)
    - [Text] Main concepts listed (left side)
    - [Text] Discoverer info card (bottom)
  Voiceover: Full intro dialogue (phonetic)
  Timing: Synchronized with element appearance

Example intro scene:
```json
{
  "id": "intro_dialogue",
  "description": "Introduction to Quadratic Equations with context",
  "voiceover": "Hello everyone! Ok, today we are going to learn something 
               new. Don't worry, we are not just going to solve questions, 
               we are going to understand why things happen and how they work. 
               [pause] First, let's think about what Quadratic Equations are 
               about. Imagine a ball thrown in the air - it follows a curved 
               path that goes up and then comes down. This chapter will help 
               us understand things like this.",
  "elements": [
    {
      "type": "Text",
      "content": "QUADRATIC EQUATIONS",
      "position": "[0, 3.5, 0]",
      "style": {"color": "#FFFF00", "font_size": 56},
      "timing": {"start": 0.0, "duration_in": 1.0, "transition_in": "Write"}
    },
    {
      "type": "Text",
      "content": "Real-life: A ball in flight follows this path",
      "position": "[4.0, 1.0, 0]",
      "style": {"color": "#FFFFFF", "font_size": 32},
      "timing": {"start": 2.0, "duration_in": 1.5, "transition_in": "FadeIn"}
    },
    {
      "type": "Text",
      "content": "Key Concepts:\nâ€¢ Finding Roots\nâ€¢ The Discriminant\nâ€¢ Quadratic Formula",
      "position": "[-4.0, 0.0, 0]",
      "style": {"color": "#00FF00", "font_size": 28},
      "timing": {"start": 4.0, "duration_in": 2.0, "transition_in": "Write"}
    },
    {
      "type": "Text",
      "content": "Discovered by: Bhaskara II (12th century)\nDeveloped the method to find roots",
      "position": "[0, -3.0, 0]",
      "style": {"color": "#87CEEB", "font_size": 24},
      "timing": {"start": 7.0, "duration_in": 1.5, "transition_in": "FadeIn"}
    }
  ]
}
```

SCENE: core_solution_scenes
  (Multiple scenes from animation_plan - UNCHANGED)
  Duration: Variable
  
SCENE: outro_dialogue
  Duration: 24-36 seconds
  Elements:
    - [Text] Summary key points
    - [Text] Reflection questions
    - [Text] Inspiration message
  Voiceover: Full outro dialogue (phonetic)

8.9 QUALITY ASSURANCE FOR INTRO/OUTRO
------------------------------------
VALIDATION CHECKLIST:

Intro Dialogue:
  â˜ Opens with engaging hook ("Hello everyone!")
  â˜ Real-life example is relatable and contextual
  â˜ Introduces exactly 3 key concepts
  â˜ Asks "why do we need this" question
  â˜ Includes discoverer name, year, and discovery story
  â˜ Mentions real-world applications
  â˜ Transitions smoothly to core solution
  â˜ Total length: 60-90 words
  â˜ No mathematical equations (conceptual only)
  â˜ Voiceover is phonetically correct (no symbols)

Outro Dialogue:
  â˜ Summarizes 3 main points from solution
  â˜ Encourages observation in daily life
  â˜ Poses reflection questions (3)
  â˜ Ends with inspirational message about discovery
  â˜ Total length: 60-90 words
  â˜ Connects back to intro context
  â˜ Voiceover is phonetically correct
  â˜ Final line: "See you in the next lesson!"

Integration:
  â˜ Intro dialogue appears before core solution
  â˜ Core solution is mathematically unchanged
  â˜ Outro dialogue appears after core solution
  â˜ All three components have consistent tone
  â˜ Total voiceover duration: 120-180 seconds (2-3 minutes)
  â˜ Animation sync: Voiceovers match visual timing

8.10 EXAMPLE: COMPLETE RESPONSE WITH SCRIPT
------------------------------------------
QUESTION: "How do I solve 2xÂ² + 3x + 1 = 0?"

SEGMENT A: INTRO DIALOGUE (auto-generated)
---
"Hello everyone! Ok, today we are going to learn something new. 
Don't worry, we are not just going to solve questions, we are going to 
understand why things happen and how they work. [pause]

First, let's think about what Quadratic Equations are about. Imagine a ball 
thrown in the air - it follows a beautiful curved path that goes up and then 
comes back down. This chapter will help us understand things like this.

Now, let's see the main ideas. The first idea is Finding the Roots - these are 
the x-values where the equation equals zero. The second idea is The Discriminant - 
this tells us how many solutions exist. And the third idea is The Quadratic Formula - 
this is the tool we use to find the roots. But why do we need to know this? 
Well, these ideas help us see patterns, make decisions, or understand the world 
around us.

Before we do any calculations or numbers, let's think about how these ideas work. 
How does a parabola behave? Why does it sometimes touch the x-axis at one point 
and sometimes at two? What if we change the coefficients? Asking these questions 
helps us really understand, not just remember.

Also, it is interesting to know who discovered these ideas. Bhaskara II, an Indian 
mathematician, discovered this concept in the 12th century because he was solving 
practical problems about trade and agriculture that led to quadratic equations. 
Imagine being that person, trying to figure out something no one else knew. 
That's why we study their workâ€”it helps us see how ideas grow.

Let's also see how this is useful in real life. For Physics, it helps us understand 
projectile motion - where a ball lands, how far it travels. For Economics, it helps 
in calculating break-even points and profit optimization. For Engineering, it helps 
design arches and bridges.

Ok now let's dive into YOUR specific problem. Keep these ideas in mind as we work 
through the solution together."
---

SEGMENT B: CORE SOLUTION (unchanged)
---
[Mathematical solution with steps, as before]
---

SEGMENT C: OUTRO DIALOGUE (auto-generated)
---
"Ok, now let's remember what we learned today. The main points are: 
First, we learned how to identify the coefficients a, b, and c from a quadratic 
equation. Second, we calculated the discriminant to understand how many solutions 
exist. And third, we used the quadratic formula to find the exact roots.

Try to see these ideas in your daily life. Next time you see a basketball arc, 
or a bridge curve, or hear about a company's profit forecast, ask yourself:
- Why does this follow a parabolic shape?
- How many solutions or optimal points are there?
- What would happen if we changed the conditions?

And think about Bhaskara II - what problems was he trying to solve? Why was 
understanding roots so important for trade in ancient India?

Here are some questions to think about:
- Can a quadratic equation have no real solutions? When and why?
- How would you use this to find when a ball hits the ground?
- Could you create your own quadratic equation that models something you observe?

That's all for today. Keep thinking, asking questions, and trying to connect 
ideas with real life. Learning is not just about remembering, it's about 
understanding and imagining. And who knows, maybe one day you will discover 
something new too! See you in the next lesson!"
---

================================================================================
END OF DETAILS
================================================================================
